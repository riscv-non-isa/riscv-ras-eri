== Error Reporting

Components (e.g., a RISC-V hart, a memory controller, etc.) in a system that
support error detection may implement one or more banks of error records. Each
error bank may implement one or more error records. Each error record
corresponds to one or more hardware units of the component and reports errors
detected by those hardware units. A hardware unit may implement multiple error
records. One or more error records may be valid at any instance of time due to
one or more hardware units in the component detecting an error or due to a
hardware unit having detected one or more errors.

Each error bank is memory-mapped starting at an 8-byte aligned physical address
and may include up to 63 error records. Each error record is a set of registers
used to control that error record and to report status, address, and other
information relevant to the error recorded in that error record.

[NOTE]
====
Implementations may implementing a coarser alignment for the start address of
an error bank. For example, some implementations may locate the error bank
within a naturally aligned 4-KiB region (a page) of physical address space for
each error bank, i.e., one page per bank. Coarser alignments may enable register
decoding to be implemented without a hardware adder circuit.
====

The behavior for register accesses where the address is not aligned to
the size of the access, or if the access spans multiple registers, or if the
size of the access is not 4 bytes or 8 bytes, is `UNSPECIFIED`. An aligned 4
byte access to a RERI register must be single-copy atomic. Whether an 8 byte
access to an RERI register is single-copy atomic is `UNSPECIFIED`, and such an
access may appear, internally to the RERI implementation, as if two separate 4
byte accesses were performed.

[NOTE]
====
The RERI registers are defined in such a way that software can perform two
individual 4 byte accesses, or hardware can perform two independent 4 byte
transactions resulting from an 8 byte access, to the high and low halves of the
register as long as the register semantics, with regards to side-effects, are
respected between the two software accesses, or two hardware transactions,
respectively.
====

The RERI registers have little-endian byte order (even for systems where
all harts are big-endian-only).

[NOTE]
====
Big-endian-configured harts that make use of an RERI may implement the `REV8`
byte-reversal instruction defined by the Zbb extension. If `REV8` is not
implemented, then endianness conversion may be implemented using a sequence
of instructions.
====

An implementation-specific response occurs if the error bank and/or record is
unavailable (e.g., powered down) to memory-mapped accesses. For example, an
error bank and/or record may respond with all zero data on reads and may
ignore writes. Other implementations may for example, signal a error response on
the attempted transaction.

A error bank that is otherwise available for memory-mapped accesses must respond
with all zero data on reads and must ignore writes to unimplemented registers in
the page.

=== Register Layout

The error bank registers are organized as a 64-byte header providing information
about the error bank followed by an array of 64-byte error records. The offset
of the error record numbered `i` in the bank is (64 + `i` * 64) where `i` may
range from 0 to 62.

.Error bank Memory-mapped register layout
[width=100%]
[%header, cols="^9,9,^3, 27"]
|===
|Offset       |Name               |Size|Description
|  0          |`vendor_n_imp_id`  |8   |Vendor and implementation ID.
|  8          |`bank_info`        |8   |Error bank information.
| 16          |`valid_summary`    |8   |Summary of valid error records.
| 24          | Reserved          |32  |Reserved for future standard use.
| 56          | Custom            |8   |Designated for custom use.
| 64 + 64 * i |`control_i`        |8   |Control register of error record i.
| 72 + 64 * i |`status_i`         |8   |Status register of error record i.
| 80 + 64 * i |`addr_i`           |8   |Address register of error record i.
| 88 + 64 * i |`info_i`           |8   |Information register of error record i.
| 96 + 64 * i |`suppl_info_i`     |8   |Supplemental information register of
                                        error record i.
|104 + 64 * i |`timestamp_i`      |8   |Timestamp register of error record i.
|112 + 64 * i | Reserved          |8   |Reserved for future standard use.
|120 + 64 * i | Reserved          |8   |Reserved for future standard use.
|===

All registers and register fields defined by this specification are WARL unless
noted otherwise. While all registers and register fields of an error bank and
the error records in an error bank must exist, is legal to implement a register
and/or register field of as read-only zero or a read-only legal value if they
are not required to report error information in an implementation.

[NOTE]
====
The number of error banks, the number of error records in an error bank and the
amount of information reported in an error record may be implemented to meet the
needs of the implementation. The error records are only required to implement the
registers and register fields needed to report error information that is legally
produced by the implementation.

A minimal implementation with one error bank, which contains one error record
only consumes 128 bytes of address space. In terms of storage, the minimal
implementation can come down to a single bit of storage for the `v` (valid) bit
in the `status_i` register in the single error record. All other register fields
of the bank header and error record are WARL and may be hardwired to read-only
zero or read-only one as appropriate.
====

=== Reset Behavior

The reset value is `UNSPECIFIED` for RERI registers.

The registers of an error bank may preserve their value across certain types of
reset. For example, a warm reset or a RAS initiated reset may preserve the
register values whereas a cold reset may reset the values back to their initial
state.

[NOTE]
====
Under normal circumstances, when an error is signaled, the RAS handler retrieves
the logged errors to process the error condition. In some cases, the RAS handler
may not be able to do such processing. For example, the system may be unable to
support execution of the RAS handler and cause a RAS initiated reset. Preserving
the information logged in error records across such resets allows reporting of
unhandled errors that occurred in a previous boot of the system.
====

All registers in an error bank must have the same reset behavior.

=== Error Bank Header Registers

==== Vendor and Implementation ID (`vendor_n_imp_id`)

The `vendor_n_imp_id` register is a read-only register and its layout is:

.Vendor and implementation ID
[wavedrom, , ]
....
{reg: [
  {bits: 32, name: 'vendor_id'},
  {bits: 16, name: 'imp_id'},
  {bits: 16, name: 'WPRI'},
], config:{lanes: 2, hspace:1024}}
....

The `vendor_id` field follows the encoding as defined by `mvendorid` CSR and
provides the JEDEC manufacturer ID of the provider of the component hosting the
error bank. A value of 0 may be returned to indicate the field is not
implemented or that this is a non-commercial implementation.

The `imp_id` provides a unique identity, defined by the vendor, to identify the
component and revisions of the component implementation hosting the error bank.
A value of 0 may be returned to indicate that the field is not implemented. The
value returned should reflect the design of the component itself and not of the
surrounding system.

[NOTE]
====
The `vendor_id` and the `imp_id` are expected to be used as a identifier to
determine the format of fields and encodings that are `UNSPECIFIED` by this
specification.
====

<<<

==== Error Bank Information (`bank_info`)

The `bank_info` is a read-only register and its layout is as follows:

.Error bank information
[wavedrom, , ]
....
{reg: [
  {bits: 16, name: 'inst_id'},
  {bits: 16, name: 'n_err_recs'},
  {bits: 24, name: 'WPRI'},
  {bits:  8, name: 'version'},
], config:{lanes: 2, hspace:1024}}
....

The `version` field returns the version of the architectural register layout
specification implemented by the error bank. The version defined by this
specification is 0x01.

[NOTE]
====
The offset of the `version` field in the error bank shall not change across
versions of the register layout. Software should first read the `version` field
and use the value to determine the register layout.
====

The `inst_id` field identifies a unique instance of an error bank, within a
package or at least a silicon die, of the component; ideally unique in the whole
system. The `inst_id` are defined by the vendor of the system as a unique
identifier for the component. A value of 0 may be returned to indicate the field
is not implemented.

[NOTE]
====
The `inst_id` are expected to be collected and logged as part of the RAS error
logs. These may allow the vendor of the silicon to make inferences about the
instances of the components that may be vulnerable. As these values differ
between vendors of the system and even among systems provided by the same
vendor, these are not expected to be useful to the majority of software besides
software intimately familiar with that system implementation.
====

The `n_err_recs` field indicates the number of error records implemented by the
error bank. The field is allowed to have a unsigned value between 1 and 63. The
error records of an error bank are located in the 4 KiB memory mapped region
reserved for the error bank such that the first error record is at offset 64
and the last error record at offset (64 + 63 * `n_err_recs`).

==== Summary of Valid Error Records (`valid_summary`)

The `valid_summary` is a read-only register and its layout is as follows:

.Summary of valid error records
[wavedrom, , ]
....
{reg: [
  {bits: 1,  name: 'sv'},
  {bits: 63, name: 'valid_bitmap'},
], config:{lanes: 4, hspace:1024}}
....

<<<

The `sv` bit when 1 indicates that the `valid_bitmap` provides a summary of the
`valid` bits from the status registers of this error bank. If this bit is 0
then the error bank does not provide a summary of valid bits and the
`valid_bitmap` is 0.

[NOTE]
====
If `SV` is 1, then software may use the `valid_bitmap` to determine which error
records in the bank are valid. If this bit is 0 then software must read the
`status_register_i` of each implemented error record in this bank to determine
if there is a valid error logged in that error record.
====

=== Error Record Registers

==== Control Register (`control_i`)

The `control_i` is a read/write WARL register used to control error reporting by
the corresponding error record in the error bank. The layout of this register
is as follows:

.Control register
[wavedrom, , ]
....
{reg: [
  {bits: 1,  name: 'else'},
  {bits: 1,  name: 'cece'},
  {bits: 1,  name: 'sinv'},
  {bits: 1,  name: 'WPRI'},
  {bits: 2,  name: 'ces'},
  {bits: 2,  name: 'udes'},
  {bits: 2,  name: 'uues'},
  {bits: 22, name: 'WPRI'},
  {bits: 16, name: 'eid'},
  {bits: 8,  name: 'WPRI'},
  {bits: 8,  name: 'custom'},
], config:{lanes: 4, hspace:1024}}
....

Error reporting functionality in the error record is enabled if the
`else` field is set to 1. The `else` field is WARL and may default to 1 or 0 at
reset. When `else` is 1, the hardware unit logs and signals errors in the error
record. When `else` is 0, whether the hardware unit continues detecting and
correcting errors is `UNSPECIFIED`.

[NOTE]
====
When error reporting is disabled, the hardware unit may continue to
silently correct detected errors and when correction is not possible provide
corrupt data to the consumers of the data. Alternatively an implementation may
disable error detection altogether when error reporting is disabled. It
is recommended that implementations continue performing error correction even
when error reporting is disabled.

It is recommended that a hardware component continue to produce error detection
and correction codes on data generated by or stored in the hardware component even
when error reporting is disabled. It is recommended hardware components
continue to use containment techniques like data poisoning even when error
reporting is disabled.
====

The `ces`, `udes`, and `uues` are WARL fields used to enable signaling of CE, UDE,
and UUE respectively when they are logged (i.e. when `else` is 1). Enables for
unsupported classes of errors may be hardwired to 0. The encodings of these
fields are specified in <<ERR_SIG_ENABLES>>.

<<<

[[ERR_SIG_ENABLES]]
.Error signaling enable field encodings
[cols="^1,3", options="header"]
|===
| *Encoding* | *Error signal*
| 0          | Signaling is disabled.
| 1          | Signal using a Low-priority RAS signal.
| 2          | Signal using a High-priority RAS signal.
| 3          | Signal using a platform specific RAS signal.
|===

The RAS signals are usually used to notify a RAS handler. The physical
manifestation of the signal is `UNSPECIFIED` by this specification. The
information carried by the signal is `UNSPECIFIED` by this specification.

[NOTE]
====
The error signaling enables typically default to 0 - disabled - at reset to allow
a RAS handler an opportunity to initialize itself for handling RAS signals and to
initialize the hardware units that generate the RAS signals before error reporting
is enabled.

The signal generated by the error record may in addition to causing a
interrupt/event notification be also used to carry additional information to aid
the RAS handler in the platform.

The RAS handler may be implemented by a RISC-V application processor hart
in the system, a dedicated RAS handling micro-controller, a Finite-State Machine
(FSM), etc.

The error signals may be configured, through platform specific means, to notify
a RAS handler in the platform. For example, the High-priority RAS signal
may be configured to cause a High-priority RAS local interrupt, an external
interrupt, or an Non-Maskable Interrupt (NMI) and the Low-priority RAS signal
may be configured to cause a Low-priority RAS local interrupt or an external
interrupt.
====

If the error record supports corrected-error counting then the
corrected-error-counting-enable (`cece`) field, when set to 1, enables counting
corrected errors in the corrected-error-counter (`cec`) field of the status
register `status_i` of the error record. The `cec` is a counter that holds an
unsigned integer count. When `cece` is 0, the `cec` does not count and retains
its value. If corrected error counting is not supported in the error record then
`cece` and `cec` may be hardwired to 0. An overflow of `cec` is signaled using
the signal configured in the `ces` field. When `cece` is 1, the logging of a CE
in the error record does not cause an error signal and an error signal
configured in `ces` occurs only on a `cec` overflow.

The status-register-invalidate (`sinv`) bit, when written with a value of 1,
causes the `v` (valid) field of the associated `status_i` register to be
cleared. The `sinv` field always returns 0 on read. The `sinv` bit enables
software to read out and invalidate an error record without needing to
explicitly write the `status_i` register.

<<<

[NOTE]
====
Software may determine if the error record was read atomically by first reading
the registers of the error record, then clearing the valid in `status_i` by
writing 1 to `control_i.sinv` and then reading the `status_i` register again to
determine if the value (besides the `v` field) changed. If a change was detected
then the process may be repeated to read the latest reported error.
====

The error-injection-delay (`eid`) is a WARL field used to control error record
injection. When `eid` is written with a value greater than 0, the `eid` starts
counting down, at an implementation defined rate, till the value reaches a count
of 0. Writing a value of 0 disables the counter. If error injection is not
supported by the error record then the `eid` field may be hardwired to 0. When
`eid` reaches a count of 0, the status register is made valid by setting the
`status_i.v` bit to 1. The `status_i.v` transition from 0 to 1 generates a RAS
signal corresponding to the class of error (CE, UDE, or UUE) setup in the
`status_i` register. The counter continues to count even if the `status_i`
register was overwritten by a hardware detected error before the `eid` counts
down to 0.

[NOTE]
====
Software may setup the error record registers with desired values of the error
record to be injected and then program `eid` to cause the `status_i` register to
be marked valid when `eid` count reaches 0.

The error record injection capability only injects an error record and not an
error into the hardware itself. The error record injection capability is
expected to be used to test the RAS handlers and is not intended to be used for
verification of the hardware implementation itself.

Other implementation specific mechanisms may be provided to generate and/or
emulate hardware error conditions. When hardware error injection capabilities
are implemented, the implementation should ensure that these capabilities cannot
be misused to maliciously inject hardware errors that may lead to security
issues.
====

==== Status Register (`status_i`)

The `status_i` is a read-write WARL register that reports errors detected by
the hardware unit.

.Status register
[wavedrom, , ]
....
{reg: [
  {bits: 1,  name: 'v'},
  {bits: 1,  name: 'ce'},
  {bits: 1,  name: 'ude'},
  {bits: 1,  name: 'uue'},
  {bits: 2,  name: 'pri'},
  {bits: 1,  name: 'mo'},
  {bits: 1,  name: 'c'},
  {bits: 3,  name: 'tt'},
  {bits: 1,  name: 'iv'},
  {bits: 4,  name: 'at'},
  {bits: 1,  name: 'siv'},
  {bits: 1,  name: 'tsv'},
  {bits: 2,  name: 'WPRI'},
  {bits: 1,  name: 'scrub'},
  {bits: 1,  name: 'ceco'},
  {bits: 2,  name: 'WPRI'},
  {bits: 8,  name: 'ec'},
  {bits: 16, name: 'WPRI'},
  {bits: 16, name: 'cec'},
], config:{lanes: 4, hspace:1024}}
....

The error record holds a valid error log if the `v` field is 1.

If the detected error was corrected then `ce` is set to 1. If the detected error
could not be corrected but was deferred then `ude` is set to 1. If the detected
error could not be corrected or deferred and thus needs urgent handling by an
RAS handler, then the `uue` bit is set to 1. If the error record does not log a
class of errors (e.g., does not support UDE), then the corresponding bit may be
hardwired to 0. If the bits corresponding to more than one error class are set
to 1 then the error record holds information about the highest severity error
class among the bits set.

When `v` is 1, if more errors of the same class as the error currently logged in
the error record occur then the multiple-occurrence (`mo`) bit is set to indicate
the multiple occurrence of errors of the same severity. See <<OVERWRITE_RULES>>
for rules on overwriting the error record in such cases.

Each error of an error class (CE, UDE, or UUE) that may be logged in an error
record may be associated with a priority which is a number between 0 and 3;
priority value of 3 being the highest priority and priority value of 0 being the
lowest priority. The priority values indicate relative priority among errors of
the same error class. Among errors of different error classes the priority
values are unrelated.

[NOTE]
====
Some implementations may report errors from more than one sources into a
single error records. Such implementations may prioritize reporting of error
from one source over the other using the `pri` associated with the error when
both sources simultaneously detect an error of the same class (e.g., CE). The
priority is also used to determine if a new error may overwrite a previously
reported error of the same error class in the error record.
====

The `pri` field in the error record indicates the priority of the currently
logged error in the error record. The `pri` is a WARL field and an
implementation may support only a subset of legal values for this field and
an implementation that does not support reporting of a priority per error may
hardwire this field to 0.

The error record overwrite rules use the error class (CE, UDE, or UUE) and the
error priority (`pri`) as specified in <<OVERWRITE_RULES>>.

When an error occurs the containable (`c`) bit may be set to 1 to indicate
that the error has not propagated beyond the boundaries of the hardware unit
that detected the error and thus may be *containable* through recovery actions
(e.g., terminating the computation, etc.) carried out by the RAS handler.
The `c` bit is WARL.

[NOTE]
====
For example, a RISC-V hart by causing the precise data corruption exception on
attempts to consume corrupted/poisoned data may contain the error to the program
currently executing on the hart. Such errors may be reported with the `c` bit
set to 1.

While the `c` bit indicates that the error may be containable the RAS handler
may or may not be able to recover the system from such errors. The RAS handler
must make the recovery determination based on additional information provided in
the error record such as the address of the memory where corruption was
detected, etc.
====

The address-type (`at`) is a WARL field indicates the type of address reported
in the `addr_i` register. A error record that does not report addresses may
hardwire this field to 0. The encodings of the `at` field are listed in
<<AT_ENCODINGS>>.

<<<

[[AT_ENCODINGS]]
.Address type encodings
[cols="^1,3", options="header"]
|===
| *Encoding* | *Description*
| 0          | None. When `at` is 0, the contents of the `addr_i` register are
               `UNSPECIFIED`.
| 1          | Supervisor Physical Address (SPA).
| 2          | Guest Ahysical Address (GPA).
| 3          | Virtual Address (VA).
| 4-15       | Component specific.
|===

[NOTE]
====
The component specific address types may be used to report addresses such as a
local bus address, a Dynamic Random-Access Memory (DRAM) address, etc. The
interpretation of such addresses is component specific.

A set of component specific encodings are defined to allow a platform to use an
encoding per type of component specific addresses.

The `addr_i` register must hold the address of type determined by the `at`
field. Additional non-redundant information about the location accessed using
the address (e.g., cache set and way, etc.) may be reported in the `info_i`
register.
====

The transaction-type (`tt`) is a WARL field to report the type of transaction
that detected the error and its encodings are listed in <<TT_ENCODINGS>>. An
error record that does not report transaction types may hardwire this field
to 0.

[[TT_ENCODINGS]]
.Transaction type encodings
[cols="^1,3", options="header"]
|===
| *Encoding* | *Description*
| 0          | Unspecified or not applicable.
| 1          | Designated for custom use.
| 2-3        | Reserved for future standard use.
| 4          | Explicit read.
| 5          | Explicit write.
| 6          | Implicit read.
| 7          | Implicit write.
|===

[NOTE]
====
Implementations may report additional information about the transaction (e.g.,
whether speculative, on-demand vs. prefetch, etc.) in the `info_i` and/or
`suppl_info_i` registers.

For a RISC-V hart, the Privileged specification cite:[PRIV] defines memory
accesses by instructions as either explicit or implicit. Implicit read and write
are accesses that may be implicitly performed by hardware to perform an explicit
operation. For example, a load or store instruction executed by the hart may
perform implicit memory accesses to page table data structures. Instruction
memory accesses by a hart are termed as implicit accesses by the Privileged
specification. However for the purposes of error reporting only the implicit
accesses to data structures like the (guest) page tables used to determine the
address of the instruction to fetch are termed as implicit accesses. The
read to fetch the instruction bytes themselves are termed as explicit reads.

A non-hart component may also perform implicit accesses in order to process an
explicit transaction. For example, processing a memory transaction may require
a fabric component to implicitly access a routing table data structure.
====

If the detected error reports additional information in the `info_i` register
then information-valid (`iv`) field is set to 1. If the detected error reports
additional supplemental information in the `suppl_info_i` register then
supplemental-information-valid (`siv`) field is set to 1. The `iv` and/or `siv`
fields may be hardwired to 0 if the error record does not provide information in
`info_i` and/or `suppl_info_i` registers. When `iv` is 0, the value in `info_i`
register is `UNSPECIFIED`. When `siv` is 0, the value in `suppl_info_i` register
is `UNSPECIFIED`.

If the error record holds a timestamp of when the last error was logged in the
`timestamp_i` register then the timestamp-valid (`tsv`) field is set to 1. This
field may be hardwired to 0 if the error record does not report a timestamp with
the error. When `tsv` field is 0, the value in `timestamp_i` register is
`UNSPECIFIED`.

The `scrub` bit is valid when a CE is logged and when set to 1 indicates that
the storage location that held the data value has been updated with the
corrected value (i.e., the data has been scrubbed). In an implementation that
cannot make this distinction then it may conservatively report this field as 0.
When the error record is not associated with storage elements (e.g., correcting
errors detected on bus transactions) this field may be hardwired to 0. If this
property is unconditionally true for a hardware unit then this field may be
hardwired to 1.

The error-code (`ec`) is a WARL field holds an error code that provides a
description of the detected error. Standard `ec` encodings are defined in
<<EC_ENCODINGS>>. If an error record detects an error that does not correspond
to a standard `ec` encoding then such errors may be reported using a custom
encoding. The custom encodings have the most significant bit set to 1 to
differentiate them from the standard encodings.

An error record that supports the 1 setting of the `cece` field in `control_i`,
implements a corrected-error-counter in the `cec` field. The `cec` is a WARL
field. When `cece` is 1, the `cec` is incremented on each CE in addition to
logging details of the error in the error record registers. If an unsigned
integer overflow occurs on an `cec` increment then the
corrected-error-counter-overflow (`ceco`) field is set to 1. The `cec`
continues to count following an overflow. The `cec` and `ceco` fields hold valid
data and continue to count even when the `v` field is 0.

[NOTE]
====
Some hardware units may maintain a history of CE and may report a CE and may
increment the `cec` only if the error is not identical to a previously reported
CE.

Some hardware units may implement low pass filters (e.g., leaky buckets) that
throttle the rate which CE are reported and counted.

To invalidate a valid error record (presumably after having first read the error
record), software should write 1 to the `control_i.sinv` control bit to clear
the `v` bit in the `status_i` register of the error record. Using the `sinv`
control to clear the `v` bit, as compared to an explicit write to the register,
avoids overwriting the `cec` and `ceco` fields (which typically want to be
maintained across logged errors).

If software needs to initialize the `cec` and/or `ceco`, then a software write
to the `status_i` register is appropriate. Before performing the write, software
should first check for and read any valid error record and then write the register
with the new `cec` and/or `ceco` value and with `v=0` (Or, if software for some
reason wants to leave an existing valid error log in place, it should do a
read-modify-write of the status register).
====

When an UUE or UDE error is logged in an error record, the `cec` and `ceco` fields
of the error record are not modified and retain their values.

==== Address Register (`addr_i`)

The `addr_i` WARL register reports the address associated with the
detected error when `status_i.at` is not 0. If `status_i.at` is 0, the value in
this register is `UNSPECIFIED`. An implementation that does not report addresses
may hardwire this register to 0. Some fields of the register may be hardwired to
zero if the field is unused to report any type of address. In general, to the
extent possible, the error record should capture all significant parts of the
address. However as a function of the type of error being logged some address
fields may be zeroes. Some of the highest address bits may be fixed or may be
sign-extensions or may be zero-extensions of the next lowest address bit
depending on the type of address reported.

==== Information Register (`info_i`)

The `info_i` WARL register provides additional information about the error when
`status_i.iv` is 1. If `status_i.iv` is 0, the value in this register is
`UNSPECIFIED`. An implementation that does not report any additional
information may hardwire this register to 0.

The format of the register is `UNSPECIFIED` by this specification. This field
may be interpreted using the error code in `status_i.ec` along with
implementation specific and implementation defined format and rules.

[NOTE]
====
This field may be used to report error specific information to help locate the
failing component, guide recovery actions, determine whether the error is
transient or permanent, etc. The field may be used to report more detailed
information about the location of the error within the component, for example,
the set and way where the error was detected, the parity group that was in error,
the ECC syndrome, a protocol FSM state, the input that caused an assertion to
fail, etc.

Components that are field replaceable units or detect errors in connected field
replacement units may log additional information in the `info_i` register to
help identify the failing component. For example, a memory controller may log
the memory channel associated with the error such as the Dual In-line Memory
Module (DIMM) channel, bank, column, row, rank, subRank, device ID, etc.

====

==== Supplemental Information Register (`suppl_info_i`)

The `suppl_info_i` WARL register provides additional information about the error
when `status_i.siv` is 1. This information may supplement the information
provided in `info_i` register. If `status_i.siv` is 0, the value in this
register is `UNSPECIFIED`. An implementation that does not report any
supplemental information may hardwire this register to 0.

The format of the register is `UNSPECIFIED` by this specification. This field
may be interpreted using the error code in `status_i.ec` along with
implementation specific and implementation defined format and rules.

==== Timestamp Register (`timestamp_i`)

The `timestamp_i` WARL register provides a timestamp for the last error recorded
in the error record if `status_i.tsv` is 1. When `status.tsv` is 0, the value in
this register is `UNSPECIFIED`. An implementation that does not report a
timestamp may hardwire this register to 0. Some fields of the register may be
hardwired to zero if the field is unused to report the timestamp.

The nature, frequency, and resolution of the timestamp are `UNSPECIFIED`.

[NOTE]
====
The timestamp may be constructed by a hardware unit using mechanism such as
sampling a local cycles counter (e.g., the cycles counter of a RISC-V hart, a
global counter (e.g, mtime, etc.), or other implementation specific means.
====

[[OVERWRITE_RULES]]
=== Error Record Overwrite Rules

When a hardware unit detects an error it may find its error record still valid
due to an earlier detected error that has not yet been consumed by software.

The overwrite rules allow a higher severity error to overwrite a lower severity
error. UUE has the highest severity, followed by UDE, and then CE. When the two
errors have same severity the priority of the errors (as determined by
`status_i.pri`) is used to determine if the error record is overwritten. Higher
priority errors overwrite the lower priority errors. When a error record is
overwritten by a higher severity error (UDE/CE by UUE, UDE by UUE, or CE by
UUE/UDE), the status bits indicating the severity of the older errors are
retained (i.e., are sticky).

When an error writes or overwrites an error record, the `status_i.cec` and
`status_i.ceco` fields update from CEs and retain value for errors of other
severity. When implemented, `cec` counts CE occurrences; unsigned integer
overflow on `cec` increment sets `ceco` to 1.

The rules for writing the error record are as follows:

[[REC_WRITE_RULE]]
.Error record writing rules
[listing]
----
    Let new_status be the value to be recorded in status_i register for the new error
    overwrite = FALSE
    if status_i.v == 1
        // There is a valid first error recorded
        if ( severity(new_error) > severity(status_i) )
            // A higher severity error may overwrite a lower severity error. UUE has
            // the highest severity, followed by UDE, and then CE. When a error
            // record is overwritten by a higher severity error, the status bits
            // indicating the severity of the older errors are retained
            // (i.e., are sticky).
            status_i.uue |= new_status.uue
            status_i.ude |= new_status.ude
            status_i.ce |= new_status.ce
            status_i.mo = 0
            overwrite = TRUE
        endif
        if ( severity(new_status) == severity(status_i) )
            // Indicate occurrence of second error of same severity by setting
            // the multiple-occurrence (MO) field to 1
            status_i.mo = 1
            // When the two errors have same severity the priority of
            // the errors (as determined by status_i.pri) is used to
            // determine if the error record is overwritten. Higher
            // priority errors overwrite the lower priority errors.
            if ( new_status.pri > status_i.pri )
                overwrite = TRUE;
            endif
        endif
    else
        // There is a no valid error recorded. The new error is recorded.
        // The severity of the new error may be one of UUE, UDE, or CE.
        // The sticky error history is cleared and the multiple occurrence
        // flag is set to 0.
        status_i.uue = new_status.uue
        status_i.ude = new_status.ude & ~new_status.uue
        status_i.ce = new_status.ce & ~new_status.uue & ~new_status.ude
        status_i.mo = 0
        overwrite = TRUE;
    endif
    if ( overwrite = TRUE )
        status_i.pri   = new_status.pri
        status_i.c     = new_status.c
        status_i.tt    = new_status.tt
        status_i.at    = new_status.at
        status_i.iv    = new_status.iv
        status_i.siv   = new_status.siv
        status_i.tsv   = new_status.tsv
        status_i.scrub = new_status.scrub
        status_i.ec    = new_status.ec
        // Update addr_i, info_i, suppl_info_i, timestamp_i with information, if
        // valid, about the new error
        status_i.v = 1
    endif

----

<<<

If the `status_i.v`, `status_i.mo`, and `status_i.uue` are all 1 then the RAS
handler should preferably restart the system to bring it to a correct state as
an UUE record has been lost. If the `status_i.v` and `status_i.mo` are 1 but
`status_i.uue` is 0 (i.e., the logged error is a UDE or a CE) then the RAS
handler may keep the system operational.

If multiple errors occur simultaneously then they may be recorded individually
in any order and the rules outlined in <<REC_WRITE_RULE>> lead to the highest
severity error among them being retained in the error record. When the error
record registers are written by an error, all registers that are written must
be written with information related to that error.

[NOTE]
====
When multiple errors occur simultaneously, some implementations may choose to
record each error individually following the rules outlined in
<<REC_WRITE_RULE>>. Other implementations may however choose to only record the
highest severity error or when they have the same severity the highest priority
error. And yet another implementation may choose to record one of the errors as
determined by implementation specific rules.
====

When a new error is recorded by the hardware unit in `status_i` register of its
error record then the signal configured in the `control_i` register for error is
asserted.

=== Error Reporting Defined by Other Standards

Standards such as PCIe cite:[PCI] and CXL cite:[CXL] define standardized error
reporting architectures such as the PCIe Advanced Error Reporting (AER).
Specifications such as CXL define a standardized set of RAS requirements for
hosts and devices.

The RISC-V RERI specification complements the error reporting architecture
defined by these standards with a RISC-V standard for reporting errors for
components that are not PCIe/CXL components. There may also be other error
reporting mechanisms, possibly custom, that are employed alongside the RERI
specification.

[NOTE]
====
The RISC-V system components such as PCIe root ports or PCIe Root Complex Event
Collectors may themselves implement error reporting compliant with the RISC-V
RERI specification and thus provide a unified error reporting mechanism in such
systems. For example, a root complex event collector may support an error record
to report errors logged in the Advanced Error Reporting (AER) log registers.
====

<<<

=== Error Code Encodings

[[EC_ENCODINGS]]
.Error code encodings
[cols="^1,5", options="header"]
|===
| *Encoding* | *Description*
|   0        | None
|   1        | Other unspecified error occurred
|   2        | Corrupted data access (e.g., attempt to consume poisoned data) error
|   3        | Cache block data (e.g., ECC error on cache data) error
|   4        | Cache scrubbing detected (e.g., ECC error on cache data) error
|   5        | Cache address/control state (e.g., parity error tag or state) error
|   6        | Cache unspecified error
|   7        | Snoop-filter/directory address/control state
               (e.g., ECC error on tag or state) error
|   8        | Snoop-filter/directory unspecified error
|   9        | TLB/Page-walk cache data (e.g., ECC error on TLB data) error
|  10        | TLB/Page-walk cache address/control state (e.g., ECC error on TLB
               tag) error
|  11        | TLB/Page-walk cache unspecified error
|  12        | Hart state error (e.g., ECC error on CSRs or x/f/v registers)
|  13        | Interrupt controller state (e.g., ECC error on interrupt
               pending/enable state) error
|  14        | Interconnect data (e.g., ECC error on data bus) error
|  15        | Interconnect other (e.g., parity error on address bus) error
|  16        | Internal watchdog error
|  17        | Internal datapath, memory, or execution units error
               (e.g, ALU datapath parity)
|  18        | System memory command/address bus error
|  19        | System memory unspecified error
|  20        | System memory data (e.g., ECC error in SDRAM or HBM) error
|  21        | System Memory scrubbing detected error
|  22        | Protocol Error - illegal input/output error
|  23        | Protocol Error - illegal/unexpected state error
|  24        | Protocol Error - timeout error
|  25        | System internal controller (power management, security, etc.) error
|  26        | Deferred error pass-through (e.g., forwarding poisoned data) not supported
|  27        | PCIe/CXL detected (e.g., logged into PCIe AER,
               CXL.mem error log, etc.) errors
|  28 - 63   | Reserved for future standard use
|  64 - 255  | Designated for custom use
|===
